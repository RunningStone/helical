import logging
import numpy as np
from anndata import AnnData
from torch.utils.data import DataLoader
from helical.models.uce.uce_config import UCEConfig
from helical.models.helical import HelicalRNAModel
from helical.models.uce.uce_utils import get_ESM2_embeddings, get_positions, get_protein_embeddings_idxs, load_model, prepare_expression_counts_file, get_gene_embeddings
from accelerate import Accelerator
from helical.services.downloader import Downloader
from helical.models.uce.uce_dataset import UCEDataset
import scipy
from pathlib import Path
from helical.models.uce.gene_embeddings import load_gene_embeddings_adata
import scanpy as sc

LOGGER = logging.getLogger(__name__)
class UCE(HelicalRNAModel):
    """Universal Cell Embedding Model. This model reads in single-cell RNA-seq data and outputs gene embeddings. 
        This model particularly uses protein-embeddings generated by ESM2. 
        Currently we support human and macaque species but you can add your own species by providing the protein embeddings.

        Example
        -------
        >>> from helical.models import UCE, UCEConfig
        >>> import anndata as ad
        >>> configurer=UCEConfig(batch_size=10)
        >>> uce = UCE(configurer=configurer)
        >>> ann_data = ad.read_h5ad("./10k_pbmcs_proc.h5ad")
        >>> dataset = uce.process_data(ann_data[:100])
        >>> embeddings = uce.get_embeddings(dataset)

        Parameters
        ----------
        configurer : UCEConfig, optional, default = default_configurer
            The model configuration.

        Returns
        -------
        None

        Notes
        -----
        The Universal Cell Embedding Papers has been published on `BioRxiv <https://www.biorxiv.org/content/10.1101/2023.11.28.568918v1>`_ and it is built on top of `SATURN <https://www.nature.com/articles/s41592-024-02191-z>`_ published in Nature.
        """
    default_configurer = UCEConfig()

    def __init__(self, configurer: UCEConfig = default_configurer) -> None:    
        super().__init__()
        self.config = configurer.config

        downloader = Downloader()
        for file in self.config["list_of_files_to_download"]:
            downloader.download_via_name(file)

        self.model_dir = self.config['model_path'].parent
        self.device = self.config["device"]
        self.embeddings = get_ESM2_embeddings(self.config["token_file_path"], self.config["token_dim"])
        self.model =  load_model(self.config['model_path'], self.config, self.embeddings)
        self.model = self.model.eval().to(self.device)

        if self.config["accelerator"] or self.device=='cuda':
            self.accelerator = Accelerator(project_dir=self.model_dir)#, cpu=self.config["accelerator"]["cpu"])
            self.model = self.accelerator.prepare(self.model)
        else:
            self.accelerator = None
        LOGGER.info(f"Model finished initializing.")

    def process_data(self, data: AnnData, 
                     species: str = "human", 
                     filter_genes_min_cell: int = None, 
                     embedding_model: str = "ESM2" ) -> DataLoader:
        """Processes the data for the Universal Cell Embedding model

        Parameters 
        ----------
        data : AnnData
            The AnnData object containing the data to be processed. 
            The UCE model requires the gene expression data as input and the gene symbols as variable names (i.e. as adata.var_names).
        species: str, optional, default = "human"
            The species of the data.  Currently we support "human" and "macaca_fascicularis" but more embeddings will come soon.
        filter_genes_min_cell: int, default = None
            Filter threshold that defines how many times a gene should occur in all the cells.
        embedding_model: str, optional, default = "ESM2"
            The name of the gene embedding model. The current option is only ESM2.

        Returns
        -------
        DataLoader
            The DataLoader object containing the processed data
        """
        
        files_config = {
            "spec_chrom_csv_path": self.model_dir / "species_chrom.csv",
            "protein_embeddings_dir": self.model_dir / "protein_embeddings/",
            "offset_pkl_path": self.model_dir / "species_offsets.pkl"
        }

        if filter_genes_min_cell is not None:
            sc.pp.filter_genes(data, min_cells=filter_genes_min_cell)
            # sc.pp.filter_cells(ad, min_genes=25)
        ##Filtering out the Expression Data That we do not have in the protein embeddings
        filtered_adata, species_to_all_gene_symbols = load_gene_embeddings_adata(adata=data,
                                                                        species=[species],
                                                                        embedding_model=embedding_model,
                                                                        embeddings_path=Path(files_config["protein_embeddings_dir"]))
        
        # TODO: What about hv_genes? See orig.
        if scipy.sparse.issparse(filtered_adata.X):
            gene_expression = np.asarray(filtered_adata.X.todense())
        else:
            gene_expression = np.asarray(filtered_adata.X)

        name = "test"
        gene_expression_folder_path = "./"
        prepare_expression_counts_file(gene_expression, name, gene_expression_folder_path)
        
        # shapes dictionary
        num_cells = filtered_adata.X.shape[0]
        num_genes = filtered_adata.X.shape[1]
        shapes_dict = {name: (num_cells, num_genes)}

        pe_row_idxs = get_protein_embeddings_idxs(files_config["offset_pkl_path"], species, species_to_all_gene_symbols, filtered_adata)
        dataset_chroms, dataset_start = get_positions(Path(files_config["spec_chrom_csv_path"]), species, filtered_adata)

        if not (len(dataset_chroms) == len(dataset_start) == num_genes == pe_row_idxs.shape[0]): 
            LOGGER.error(f'Invalid input dimensions for the UCEDataset! ' 
                        f'dataset_chroms: {len(dataset_chroms)}, '
                        f'dataset_start: {len(dataset_start)}, '
                        f'num_genes: {num_genes}, '
                        f'pe_row_idxs.shape[0]: {pe_row_idxs.shape[0]}')
            raise AssertionError
        
        dataset = UCEDataset(sorted_dataset_names = [name],
                             shapes_dict = shapes_dict,
                             model_config = self.config,
                             expression_counts_path = gene_expression_folder_path,
                             dataset_to_protein_embeddings = pe_row_idxs,
                             datasets_to_chroms = dataset_chroms,
                             datasets_to_starts = dataset_start
                             )
        batch_size = self.config["batch_size"]
        dataloader = DataLoader(dataset, 
                                batch_size=batch_size, 
                                shuffle=False,
                                collate_fn=dataset.collator_fn,
                                num_workers=0)
        
        LOGGER.info(f'UCE Dataset and DataLoader prepared. Setting batch_size={batch_size} for inference.')

        if self.accelerator is not None:
            dataloader = self.accelerator.prepare(dataloader)

        return dataloader

    def get_embeddings(self, dataloader: DataLoader) -> np.array:
        """Gets the gene embeddings from the UCE model

        Parameters
        ----------
        dataloader : DataLoader
            The DataLoader object containing the processed data

        Returns
        -------
        np.array
            The gene embeddings in the form of a numpy array
        """
        LOGGER.info(f"Inference started")
        embeddings = get_gene_embeddings(self.model, dataloader, self.accelerator)
        return embeddings
